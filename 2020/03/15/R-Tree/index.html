<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"monsterjang.github.io",root:"/",scheme:"Pisces",version:"7.7.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="R树很好地解决了高维空间搜索问题。它把B树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解结点的方法，保证树的平衡性。因此，R树就是一棵用来存储高维数据的平衡树。以下参考B树，B+树，B*树以及R树的介绍记录对R树的学习，并给出自己的实现"><meta property="og:type" content="article"><meta property="og:title" content="R-Tree"><meta property="og:url" content="https://monsterjang.github.io/2020/03/15/R-Tree/index.html"><meta property="og:site_name" content="M1saki"><meta property="og:description" content="R树很好地解决了高维空间搜索问题。它把B树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解结点的方法，保证树的平衡性。因此，R树就是一棵用来存储高维数据的平衡树。以下参考B树，B+树，B*树以及R树的介绍记录对R树的学习，并给出自己的实现"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://hi.csdn.net/attachment/201106/8/8394323_130749300836fQ.jpg"><meta property="og:image" content="http://hi.csdn.net/attachment/201106/7/8394323_1307440584OHk3.jpg"><meta property="og:image" content="http://hi.csdn.net/attachment/201106/8/8394323_1307492843D0oO.jpg"><meta property="og:image" content="http://hi.csdn.net/attachment/201106/8/8394323_1307512429kp03.jpg"><meta property="og:image" content="http://hi.csdn.net/attachment/201106/7/8394323_1307440584MfmI.jpg"><meta property="og:image" content="http://hi.csdn.net/attachment/201106/7/8394323_1307440583IgJP.jpg"><meta property="og:image" content="http://hi.csdn.net/attachment/201106/7/8394323_1307440583m707.jpg"><meta property="og:image" content="http://hi.csdn.net/attachment/201106/7/8394323_1307440582Z061.jpg"><meta property="og:image" content="http://hi.csdn.net/attachment/201106/7/8394323_1307440582wJqQ.jpg"><meta property="og:image" content="http://hi.csdn.net/attachment/201106/7/8394323_1307440581fXBx.jpg"><meta property="og:image" content="http://hi.csdn.net/attachment/201106/7/8394323_1307440581AIPa.jpg"><meta property="og:image" content="http://hi.csdn.net/attachment/201106/8/8394323_1307512429351R.jpg"><meta property="og:image" content="http://hi.csdn.net/attachment/201106/8/8394323_1307512428Ii2z.jpg"><meta property="og:image" content="http://hi.csdn.net/attachment/201106/8/8394323_13075124166AX3.jpg"><meta property="og:image" content="http://hi.csdn.net/attachment/201106/8/8394323_1307512414AUi3.jpg"><meta property="article:published_time" content="2020-03-15T01:42:00.000Z"><meta property="article:modified_time" content="2020-03-16T07:11:08.577Z"><meta property="article:author" content="M1saki"><meta property="article:tag" content="r-tree"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://hi.csdn.net/attachment/201106/8/8394323_130749300836fQ.jpg"><link rel="canonical" href="https://monsterjang.github.io/2020/03/15/R-Tree/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>R-Tree | M1saki</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">M1saki</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://monsterjang.github.io/2020/03/15/R-Tree/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar_1.jpg"><meta itemprop="name" content="M1saki"><meta itemprop="description" content="不要低估你的能力<br>不要高估你的毅力"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="M1saki"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">R-Tree</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-03-15 09:42:00" itemprop="dateCreated datePublished" datetime="2020-03-15T09:42:00+08:00">2020-03-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-03-16 15:11:08" itemprop="dateModified" datetime="2020-03-16T15:11:08+08:00">2020-03-16</time></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>5.8k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>R树很好地解决了高维空间搜索问题。它把B树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解结点的方法，保证树的平衡性。因此，R树就是一棵用来存储高维数据的平衡树。</p><p>以下参考<a href="https://blog.csdn.net/peterchan88/article/details/52248714" target="_blank" rel="noopener">B树，B+树，B*树以及R树的介绍</a>记录对R树的学习，并给出自己的实现</p><a id="more"></a><p>1984年，加州大学伯克利分校的 Guttman 发表了一篇题为 “R-trees: a dynamic index structure for spatial searching” 的论文，向世人介绍了R树这种处理高维空间存储问题的数据结构。</p><h2 id="r树的数据结构"><a class="markdownIt-Anchor" href="#r树的数据结构"></a> R树的数据结构</h2><p>R树是B树在高维空间的扩展，是一棵平衡树。每个R树的叶子结点包含了多个指向不同数据的指针，这些数据可以是存放在硬盘中的，也可以是存在内存中。根据R树的这种数据结构，当我们需要进行一个高维空间查询时，我们只需要遍历少数几个叶子结点所包含的指针，查看这些指针指向的数据是否满足要求即可。这种方式使我们不必遍历所有数据即可获得答案，效率显著提高。</p><p>R树的一个简单实例：</p><p><img src="http://hi.csdn.net/attachment/201106/8/8394323_130749300836fQ.jpg" alt=""></p><p>R树采用了一种称为 MBR(Minimal Bounding Rectangle) 的方法，在此译作“最小边界矩形”。从叶子结点开始用矩形（rectangle）将空间框起来，结点越往上，框住的空间就越大，以此对空间进行分割。</p><p><img src="http://hi.csdn.net/attachment/201106/7/8394323_1307440584OHk3.jpg" alt=""></p><p>详细解释一下这张图。先来看图（b）:</p><ol><li><p>首先我们假设所有数据都是二维空间下的点，图中仅仅标志了R8区域中的数据，也就是那个shape of data object。别把那一块不规则图形看成一个数据，我们把它看作是多个数据围成的一个区域。为了实现R树结构，我们用一个最小边界矩形恰好框住这个不规则区域，这样，我们就构造出了一个区域：R8。R8的特点很明显，就是正正好好框住所有在此区域中的数据。其他实线包围住的区域，如R9，R10，R12等都是同样的道理。这样一来，我们一共得到了12个最最基本的最小矩形。这些矩形都将被存储在子结点中。</p></li><li><p>下一步操作就是进行高一层次的处理。我们发现R8，R9，R10三个矩形距离最为靠近，因此就可以用一个更大的矩形R3恰好框住这3个矩形。</p></li><li><p>同样道理，R15，R16被R6恰好框住，R11，R12被R4恰好框住，等等。所有最基本的最小边界矩形被框入更大的矩形中之后，再次迭代，用更大的框去框住这些矩形。</p></li></ol><p>用地图的例子来解释，就是所有的数据都是餐厅所对应的地点，先把相邻的餐厅划分到同一块区域，划分好所有餐厅之后，再把邻近的区域划分到更大的区域，划分完毕后再次进行更高层次的划分，直到划分到只剩下两个最大的区域为止。要查找的时候就方便了。</p><p>下面就可以把这些大大小小的矩形存入我们的R树中去了。根结点存放的是两个最大的矩形，这两个最大的矩形框住了所有的剩余的矩形，当然也就框住了所有的数据。下一层的结点存放了次大的矩形，这些矩形缩小了范围。每个叶子结点都是存放的最小的矩形，这些矩形中可能包含有n个数据。</p><p>在这里，先不要去纠结于如何划分数据到最小区域矩形，也不要纠结怎样用更大的矩形框住小矩形，这些都是下一节我们要讨论的。</p><p>讲完了基本的数据结构，我们来讲个实例，如何查询特定的数据。又以餐厅为例，假设我要查询广州市天河区天河城附近一公里的所有餐厅地址怎么办？</p><ol><li><p>打开地图（也就是整个R树），先选择国内还是国外（也就是根结点）</p></li><li><p>然后选择华南地区（对应第一层结点），选择广州市（对应第二层结点）</p></li><li><p>再选择天河区（对应第三层结点）</p></li><li><p>最后选择天河城所在的那个区域（对应叶子结点，存放有最小矩形），遍历所有在此区域内的结点，看是否满足我们的要求即可。</p></li></ol><p>对应下图：</p><p><img src="http://hi.csdn.net/attachment/201106/8/8394323_1307492843D0oO.jpg" alt=""></p><h3 id="性质"><a class="markdownIt-Anchor" href="#性质"></a> 性质</h3><p>一棵R树满足如下的性质：</p><ul><li>除非它是根结点之外，所有叶子结点包含有m至M个记录索引（条目）。作为根结点的叶子结点所具有的记录个数可以少于m。通常，m=M/2。</li><li>对于所有在叶子中存储的记录（条目），I是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（注意：此处所说的“矩形”是可以扩展到高维空间的）。</li><li>每一个非叶子结点拥有m至M个孩子结点，除非它是根结点。</li><li>对于在非叶子结点上的每一个条目，I是最小的可以在空间上完全覆盖这些条目所代表的店的矩形（同性质2）。</li><li>所有叶子结点都位于同一层，因此R树为平衡树。</li></ul><h3 id="叶子结点的结构"><a class="markdownIt-Anchor" href="#叶子结点的结构"></a> 叶子结点的结构</h3><p>先来探究一下叶子结点的结构。叶子结点所保存的数据形式为：(I, tuple-identifier)。</p><p>其中，tuple-identifier表示的是一个存放于数据库中的tuple，也就是一条记录，它是n维的。I是一个n维空间的矩形，并可以恰好框住这个叶子结点中所有记录代表的n维空间中的点。I=(I0,I1,…,In-1)。其结构如下图所示：</p><p><img src="http://hi.csdn.net/attachment/201106/8/8394323_1307512429kp03.jpg" alt=""></p><p>下图描述的就是在二维空间中的叶子结点所要存储的信息：</p><p><img src="http://hi.csdn.net/attachment/201106/7/8394323_1307440584MfmI.jpg" alt=""></p><p>在这张图中，I所代表的就是图中的矩形，其范围是a&lt;=I0&lt;=b，c&lt;=I1&lt;=d。有两个tuple-identifier，在图中即表示为那两个点。这种形式完全可以推广到高维空间。这样，叶子结点的结构就介绍完了。</p><h3 id="非叶子结点的结构"><a class="markdownIt-Anchor" href="#非叶子结点的结构"></a> 非叶子结点的结构</h3><p>R树的非叶子结点存放的数据结构为：(I, child-pointer)。</p><p>其中，child-pointer是指向孩子结点的指针，I是覆盖所有孩子结点对应矩形的矩形。如图：</p><p><img src="http://hi.csdn.net/attachment/201106/7/8394323_1307440583IgJP.jpg" alt=""></p><p>D,E,F,G为孩子结点所对应的矩形。A为能够覆盖这些矩形的更大的矩形。这个A就是这个非叶子结点所对应的矩形。无论是叶子结点还是非叶子结点，它们都对应着一个矩形。树形结构上层的结点所对应的矩形能够完全覆盖它的孩子结点所对应的矩形。根结点也唯一对应一个矩形，而这个矩形是可以覆盖所有我们拥有的数据信息在空间中代表的点的。（这张图画的可能不那么精确，应该是矩形A要恰好覆盖D,E,F,G，而不应该留出这么多没用的空间。）</p><h2 id="r树的操作"><a class="markdownIt-Anchor" href="#r树的操作"></a> R树的操作</h2><h2 id="搜索"><a class="markdownIt-Anchor" href="#搜索"></a> 搜索</h2><p>R树的搜索操作很简单，跟B树上的搜索十分相似。它返回的结果是所有符合查找信息的记录条目。而输入可以看成是一个空间中的矩形，也就是说，我们输入的是一个搜索矩形。</p><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Function：Search</span><br><span class="line"></span><br><span class="line">描述：假设T为一棵R树的根结点，查找所有搜索矩形S覆盖的记录条目。</span><br><span class="line"></span><br><span class="line">S1:[查找子树] 如果T是非叶子结点，如果T所对应的矩形与S有重合，那么检查所有T中存储的条目，对于所有这些条目，使用Search操作作用在每一个条目所指向的子树的根结点上（即T结点的孩子结点）。</span><br><span class="line"></span><br><span class="line">S2:[查找叶子结点] 如果T是叶子结点，如果T所对应的矩形与S有重合，那么直接检查S所指向的所有记录条目。返回符合条件的记录。</span><br></pre></td></tr></table></figure><p>通过下图来理解这个Search操作。</p><p><img src="http://hi.csdn.net/attachment/201106/7/8394323_1307440583m707.jpg" alt=""></p><p><img src="http://hi.csdn.net/attachment/201106/7/8394323_1307440582Z061.jpg" alt=""></p><p>阴影部分所对应的矩形为搜索矩形。它与根结点对应的最大的矩形（未画出）有重叠。这样将Search操作作用在其两个子树上。两个子树对应的矩形分别为R1与R2。搜索R1，发现与R1中的R4矩形有重叠，继续搜索R4。最终在R4所包含的R11与R12两个矩形中查找是否有符合条件的记录。搜索R2的过程同样如此。很显然，该算法进行的是一个迭代操作。</p><h3 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h3><p>R树的插入操作也同B树的插入操作类似。当新的数据记录需要被添加入叶子结点时，若叶子结点溢出，那么我们需要对叶子结点进行分裂操作。显然，叶子结点的插入操作会比搜索操作要复杂。插入操作需要一些辅助方法才能够完成。</p><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Function：Insert</span><br><span class="line"></span><br><span class="line">描述：将新的记录条目E插入给定的R树中。</span><br><span class="line"></span><br><span class="line">I1：[为新记录找到合适插入的叶子结点] 开始ChooseLeaf方法选择叶子结点L以放置记录E。</span><br><span class="line"></span><br><span class="line">I2：[添加新记录至叶子结点] 如果L有足够的空间来放置新的记录条目，则向L中添加E。如果没有足够的空间，则进行SplitNode方法以获得两个结点L与LL，这两个结点包含了所有原来叶子结点L中的条目与新条目E。</span><br><span class="line"></span><br><span class="line">I3：[将变换向上传递] 开始对结点L进行AdjustTree操作，如果进行了分裂操作，那么同时需要对LL进行AdjustTree操作。</span><br><span class="line"></span><br><span class="line">I4：[对树进行增高操作] 如果结点分裂，且该分裂向上传播导致了根结点的分裂，那么需要创建一个新的根结点，并且让它的两个孩子结点分别为原来那个根结点分裂后的两个结点。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Function：ChooseLeaf</span><br><span class="line"></span><br><span class="line">描述：选择叶子结点以放置新条目E。</span><br><span class="line"></span><br><span class="line">CL1：[Initialize] 设置N为根结点。</span><br><span class="line"></span><br><span class="line">CL2：[叶子结点的检查] 如果N为叶子结点，则直接返回N。</span><br><span class="line"></span><br><span class="line">CL3：[选择子树] 如果N不是叶子结点，则遍历N中的结点，找出添加E.I时扩张最小的结点，并把该结点定义为F。如果有多个这样的结点，那么选择面积最小的结点。</span><br><span class="line"></span><br><span class="line">CL4：[下降至叶子结点] 将N设为F，从CL2开始重复操作。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Function：AdjustTree</span><br><span class="line"></span><br><span class="line">描述：叶子结点的改变向上传递至根结点以改变各个矩阵。在传递变换的过程中可能会产生结点的分裂。</span><br><span class="line"></span><br><span class="line">AT1：[初始化] 将N设为L。</span><br><span class="line"></span><br><span class="line">AT2：[检验是否完成] 如果N为根结点，则停止操作。</span><br><span class="line"></span><br><span class="line">AT3：[调整父结点条目的最小边界矩形] 设P为N的父节点，EN为指向在父节点P中指向N的条目。调整EN.I以保证所有在N中的矩形都被恰好包围。</span><br><span class="line"></span><br><span class="line">AT4：[向上传递结点分裂] 如果N有一个刚刚被分裂产生的结点NN，则创建一个指向NN的条目ENN。如果P有空间来存放ENN，则将ENN添加到P中。如果没有，则对P进行SplitNode操作以得到P和PP。</span><br><span class="line"></span><br><span class="line">AT5：[升高至下一级] 如果N等于L且发生了分裂，则把NN置为PP。从AT2开始重复操作。</span><br></pre></td></tr></table></figure><p>同样，我们用图来更加直观的理解这个插入操作。</p><p><img src="http://hi.csdn.net/attachment/201106/7/8394323_1307440582wJqQ.jpg" alt=""></p><p><img src="http://hi.csdn.net/attachment/201106/7/8394323_1307440581fXBx.jpg" alt=""></p><p>我们来通过图分析一下插入操作。现在我们需要插入R21这个矩形。开始时我们进行ChooseLeaf操作。在根结点中有两个条目，分别为R1，R2。其实R1已经完全覆盖了R21，而若向R2中添加R21，则会使R2.I增大很多。显然我们选择R1插入。然后进行下一级的操作。相比于R4，向R3中添加R21会更合适，因为R3覆盖R21所需增大的面积相对较小。这样就在B8，B9，B10所在的叶子结点中插入R21。由于叶子结点没有足够空间，则要进行分裂操作。</p><p>插入操作如下图所示：</p><p><img src="http://hi.csdn.net/attachment/201106/7/8394323_1307440581AIPa.jpg" alt=""></p><h3 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h3><p>R树的删除操作与B树的删除操作会有所不同，不过同B树一样，会涉及到压缩等操作。R树的删除同样是比较复杂的，需要用到一些辅助函数来完成整个操作。</p><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Function：Delete</span><br><span class="line"></span><br><span class="line">描述：将一条记录E从指定的R树中删除。</span><br><span class="line"></span><br><span class="line">D1：[找到含有记录的叶子结点] 使用FindLeaf方法找到包含有记录E的叶子结点L。如果搜索失败，则直接终止。</span><br><span class="line"></span><br><span class="line">D2：[删除记录] 将E从L中删除。</span><br><span class="line"></span><br><span class="line">D3：[传递记录] 对L使用CondenseTree操作</span><br><span class="line"></span><br><span class="line">D4：[缩减树] 当经过以上调整后，如果根结点只包含有一个孩子结点，则将这个唯一的孩子结点设为根结点。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Function：FindLeaf</span><br><span class="line"></span><br><span class="line">描述：根结点为T，期望找到包含有记录E的叶子结点。</span><br><span class="line"></span><br><span class="line">FL1：[搜索子树] 如果T不是叶子结点，则检查每一条T中的条目F，找出与E所对应的矩形相重合的F（不必完全覆盖）。对于所有满足条件的F，对其指向的孩子结点进行FindLeaf操作，直到寻找到E或者所有条目均以被检查过。</span><br><span class="line"></span><br><span class="line">FL2：[搜索叶子结点以找到记录] 如果T是叶子结点，那么检查每一个条目是否有E存在，如果有则返回T。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function：CondenseTree</span><br><span class="line"></span><br><span class="line">描述：L为包含有被删除条目的叶子结点。如果L的条目数过少（小于要求的最小值m），则必须将该叶子结点L从树中删除。经过这一删除操作，L中的剩余条目必须重新插入树中。此操作将一直重复直至到达根结点。同样，调整在此修改树的过程所经过的路径上的所有结点对应的矩形大小。</span><br><span class="line"></span><br><span class="line">CT1：[初始化] 令N为L。初始化一个用于存储被删除结点包含的条目的链表Q。</span><br><span class="line"></span><br><span class="line">CT2：[找到父条目] 如果N为根结点，那么直接跳转至CT6。否则令P为N 的父结点，令EN为P结点中存储的指向N的条目。</span><br><span class="line"></span><br><span class="line">CT3：[删除下溢结点] 如果N含有条目数少于m，则从P中删除EN，并把结点N中的条目添加入链表Q中。</span><br><span class="line"></span><br><span class="line">CT4：[调整覆盖矩形] 如果N没有被删除，则调整EN.I使得其对应矩形能够恰好覆盖N中的所有条目所对应的矩形。</span><br><span class="line"></span><br><span class="line">CT5：[向上一层结点进行操作] 令N等于P，从CT2开始重复操作。</span><br><span class="line"></span><br><span class="line">CT6：[重新插入孤立的条目] 所有在Q中的结点中的条目需要被重新插入。原来属于叶子结点的条目可以使用Insert操作进行重新插入，而那些属于非叶子结点的条目必须插入删除之前所在层的结点，以确保它们所指向的子树还处于相同的层。</span><br></pre></td></tr></table></figure><p>R树删除记录过程中的 CondenseTree 操作是不同于B树的。我们知道，B树删除过程中，如果出现结点的记录数少于半满（即下溢）的情况，则直接把这些记录与其他叶子的记录“融合”，也就是说两个相邻结点合并。然而R树却是直接重新插入。</p><p><img src="http://hi.csdn.net/attachment/201106/8/8394323_1307512429351R.jpg" alt=""></p><p><img src="http://hi.csdn.net/attachment/201106/8/8394323_1307512428Ii2z.jpg" alt=""></p><p>假设结点最大条目数为4，最小条目数为2。在这张图中，我们的目标是删除记录c。首先使用FindLeaf操作找到c所处在的叶子结点的位置——R11。当c从R11删除时，R11就只有一条记录了，少于最小条目数2，出现下溢，此时要调用CondenseTree操作。这样，c被删除，R11剩余的条目——指向记录d的指针——被插入链表Q。然后向更高一层的结点进行此操作。这样R12会被插入链表中。原理是一样的，在这里就不再赘述。</p><p><img src="http://hi.csdn.net/attachment/201106/8/8394323_13075124166AX3.jpg" alt=""></p><p><img src="http://hi.csdn.net/attachment/201106/8/8394323_1307512414AUi3.jpg" alt=""></p><p>有一点需要解释的是，我们发现这个删除操作向上传递之后，根结点的条目R1也被插入了Q中，这样根结点只剩下了R2。别着急，重新插入操作会有效的解决这个问题。我们插入R3，R12，d至它原来所处的层。这样，我们发现根结点只有一个条目了，此时根据Inert中的操作，我们把这个根结点删除，它的孩子结点，即R5，R6，R7，R3所在的结点被置为根结点。至此，删除操作结束。</p><h2 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h2><p>R树是一种能够有效进行高维空间搜索的数据结构，它已经被广泛应用在各种数据库及其相关的应用中。但R树的处理也具有局限性，它的最佳应用范围是处理2至6维的数据，更高维的存储会变得非常复杂，这样就不适用了。近年来，R树也出现了很多变体，R*树就是其中的一种，这些变体提升了R树的性能。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://blog.csdn.net/peterchan88/article/details/52248714" target="_blank" rel="noopener">B树，B+树，B*树以及R树的介绍</a></li><li>Guttman, A.; “R-trees: a dynamic index structure for spatial searching” ACM, 1984, 14</li></ul><h2 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h2><ul><li>code</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/r-tree/" rel="tag"><i class="fa fa-tag"></i> r-tree</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2020/03/01/Hexo-Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-NexT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/" rel="prev" title="Hexo + Github Pages搭建个人博客 && NexT主题个性化配置"><i class="fa fa-chevron-left"></i> Hexo + Github Pages搭建个人博客 && NexT主题个性化配置</a></div><div class="post-nav-item"><a href="/2020/03/18/TA/%E5%8A%A9%E6%95%99%E9%82%A3%E4%BA%9B%E4%BA%8B/" rel="next" title="助教那些事~">助教那些事~ <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><script>window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#r树的数据结构"><span class="nav-number">1.</span> <span class="nav-text">R树的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#性质"><span class="nav-number">1.1.</span> <span class="nav-text">性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#叶子结点的结构"><span class="nav-number">1.2.</span> <span class="nav-text">叶子结点的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非叶子结点的结构"><span class="nav-number">1.3.</span> <span class="nav-text">非叶子结点的结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#r树的操作"><span class="nav-number">2.</span> <span class="nav-text">R树的操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#搜索"><span class="nav-number">3.</span> <span class="nav-text">搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#插入"><span class="nav-number">3.1.</span> <span class="nav-text">插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除"><span class="nav-number">3.2.</span> <span class="nav-text">删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结语"><span class="nav-number">4.</span> <span class="nav-text">结语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">5.</span> <span class="nav-text">参考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录"><span class="nav-number">6.</span> <span class="nav-text">附录</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="M1saki" src="/images/avatar_1.jpg"><p class="site-author-name" itemprop="name">M1saki</p><div class="site-description" itemprop="description">不要低估你的能力<br>不要高估你的毅力</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">12</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">M1saki</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">155k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">2:21</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><canvas id="canvas"></canvas></body></html>